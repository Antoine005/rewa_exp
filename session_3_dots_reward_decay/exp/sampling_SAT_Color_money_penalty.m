function [chooseLeft,RT,choice]=sampling_SAT_Color_money_penalty(blockNo,trialNo,sv,fix_but,max_sv)%% Last updated: 2013.06.10% Modified from my_dotsX_SAT_varLength% version = 1 => disappear one by one% version =3 => will remain on the screen% YHL.2012.% CCT. 2013.09   timeBare located on the bottom of the fixation (vertical)% WSL. 2014.02 timeCircle versionglobal inputs screenInfo xCtr yCtr white width_fix buttonPress rightKey leftKeygreen = [0 175 0];red = [255 0 0];yellow = [255 255 0];black = [0 0 0];curWindow = screenInfo.curWindow;rseed = screenInfo.rseed;color = [];color1 = [];version=4;% create the square for the apertureapRect = floor(createTRect(inputs(blockNo).apXYD, screenInfo));apRect = [apRect(1)-4 apRect(2)-4 apRect(3)+4 apRect(4)+4];apD=inputs(blockNo).apXYD(:,3);     % diameter of aperture in degree.center = repmat(screenInfo.center,size(inputs(blockNo).apXYD(:,1)));d_ppd 	= floor(apD/10 * screenInfo.ppd);	% size of aperture in pixelscenter = [center(:,1)+inputs(blockNo).apXYD(:,1)/10*screenInfo.ppd center(:,2)-inputs(blockNo).apXYD(:,2)/10*screenInfo.ppd]; % where you want the center of the apertureapRect = [apRect(1) apRect(2) apRect(3) apRect(4)];dotSize = 4;dot_show = [inputs(blockNo).trial_x_shift(trialNo,:);inputs(blockNo).trial_y_shift(trialNo,:)];%%% if ~isfield(dotInfo(blockNo),'maxDotTime') || (isempty(dotInfo(blockNo).maxDotTime) && ndots>0),%     % if maxDotTime is not the name of a field in the structural array%     % dotInfo, or, if dotInfo.maxDotTime is empty and number of dots > 0%     continue_show = -1;% elseif ndots > 0,%TimeMax=max(inputs(1).trial_timeLimit);currTime=inputs(blockNo).trial_timeLimit(trialNo);continue_show = round(currTime*screenInfo.monRefresh);t_practice=2;show_practice=round(t_practice*screenInfo.monRefresh);show_Speed=round(currTime*screenInfo.monRefresh);time_total = continue_show;t_moneyOnset=inputs(blockNo).t_moneyOnset;dontclear = screenInfo.dontclear;% THE MAIN LOOPframes = 0;%chooseLeft=-1;RT=-1;endExpt=0;dTime=inputs(blockNo).trial_timeLimit(trialNo);stim_start = Screen('Flip',curWindow);t_stim_pass = 1/(inputs(blockNo).sampleRate*dTime);t_constrain=6+t_moneyOnset;% dot_present = 1/(inputs(blockNo).presentTime*dTime);x=1;y=1;count = 1;indx = 1;t_fixRDM=1;sizeAngle = 0;startAngle = 0;show_Angle=0;can_not_change=0;choice = [1 2];sizeAngle_total=360*(sv/max_sv);showAngle_total=360*(sv/max_sv);%% draw fixation and show the speed of current trial and  the choice% draw the choicedirR=170;radius_choice=30;RedisLeft=inputs(blockNo).trial_redLeft(trialNo,1) ;dir_show = [dirR 0; -dirR 0]+repmat(center(1,:),2,1);if RedisLeft == 1    Left_color=red;    Right_color=green;else    Left_color=green;    Right_color=red;endwhile show_practice    arc_range=apD*2+10;    arc_range_K=arc_range+2;    % Screen(screenInfo.curWindow,'DrawLine',white,xCtr,yCtr-width_fix/2,xCtr,yCtr+width_fix/2,2);    % Screen(screenInfo.curWindow,'DrawLine',white,xCtr+width_fix/2,yCtr,xCtr-width_fix/2,yCtr,2);    Screen('FillOval', curWindow, Right_color, [dir_show(choice(1),1)-radius_choice, dir_show(choice(1),2)-radius_choice, dir_show(choice(1),1)+radius_choice, dir_show(choice(1),2)+radius_choice]');    Screen('FillOval', curWindow, Left_color, [dir_show(choice(2),1)-radius_choice, dir_show(choice(2),2)-radius_choice, dir_show(choice(2),1)+radius_choice, dir_show(choice(2),2)+radius_choice]');        show_Angle = show_Angle + (360*(sv/max_sv))/time_total;    Screen('FrameArc',curWindow, white, [xCtr-arc_range yCtr-arc_range xCtr+arc_range yCtr+arc_range], 0,sizeAngle_total,4);    Screen('FrameArc',curWindow, black, [xCtr-arc_range_K yCtr-arc_range_K xCtr+arc_range_K yCtr+arc_range_K], 0,show_Angle,10);    %     Screen(screenInfo.curWindow,'Flip');        show_practice=show_practice-1;    if show_Angle>showAngle_total        break    end    Screen(screenInfo.curWindow,'Flip');endScreen('FillOval', curWindow, Right_color, [dir_show(choice(1),1)-radius_choice, dir_show(choice(1),2)-radius_choice, dir_show(choice(1),1)+radius_choice, dir_show(choice(1),2)+radius_choice]');Screen('FillOval', curWindow, Left_color, [dir_show(choice(2),1)-radius_choice, dir_show(choice(2),2)-radius_choice, dir_show(choice(2),1)+radius_choice, dir_show(choice(2),2)+radius_choice]');Screen(screenInfo.curWindow,'DrawLine',white,xCtr,yCtr-width_fix/2,xCtr,yCtr+width_fix/2,2);Screen(screenInfo.curWindow,'DrawLine',white,xCtr+width_fix/2,yCtr,xCtr-width_fix/2,yCtr,2);t_beforeRDM=Screen(screenInfo.curWindow,'Flip');Screen(screenInfo.curWindow,'Flip',t_beforeRDM+t_fixRDM);%% Begin!!!start_time = GetSecs;while continue_show        %         dTime=inputs(blockNo).trial_timeLimit(trialNo)-t_stim_pass;    %    %         if dTime<=0    %             break    %         end        if frames>=1        [buttonPress,time,keyCode]=KbCheck;        if can_not_change==0;            if buttonPress                if strcmp(KbName(keyCode),rightKey)                    chooseLeft=0;                    RT = time-start_time;                    can_not_change=1;                                    break                elseif strcmp(KbName(keyCode),leftKey)                    chooseLeft=1;                    RT = time-start_time;                    can_not_change=1;                                    break                elseif strcmp(KbName(keyCode),'esc')                    endExpt=1;                    break                end            end        end    end    %     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        Screen('Flip', curWindow,0,dontclear);    % Flip by default will sync with vertical retrace.        Screen('BlendFunction', curWindow, GL_ONE, GL_ZERO);        Screen('FillRect', curWindow, [0 0 0 255]);        for df = 1 : 1        % square that dots do not show right in%         Screen('FillRect', curWindow, [0 0 0 0], apRect(1,:));        % circle that dots do show right in        Screen('FillOval', curWindow, [0 0 0 255], apRect(1,:));    end        Screen('BlendFunction', curWindow, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA);        if inputs(blockNo).trial_samples(trialNo,x) == 1        color(:,count) = red';    else        color(:,count) = green';    end        if RT<0        overlap=inputs(1).sampleRate*2 ;        if version == 1            Screen('DrawDots', curWindow, dot_show(:,x)', 8, color(:,x), center(1,:));        elseif version == 2 || version==4            %             tic            if x > overlap                Screen('DrawDots', curWindow, dot_show(:,(x-(overlap-1)):x), dotSize, color(:,(x-(overlap-1)):x), center(1,:));            else                Screen('DrawDots', curWindow, dot_show(:,1:x), dotSize, color(:,1:x), center(1,:));            end        elseif version == 3            Screen('DrawDots', curWindow, dot_show(:,1:x), 4, color(:,1:count), center(1,:));            Screen('DrawDots', curWindow, dot_show(:,1:y), 4, color1(:,1:count), center(1,:));        end    end        % draw the choice    if chooseLeft ==-1        Screen('FillOval', curWindow, Right_color, [dir_show(choice(1),1)-radius_choice, dir_show(choice(1),2)-radius_choice, dir_show(choice(1),1)+radius_choice, dir_show(choice(1),2)+radius_choice]');        Screen('FillOval', curWindow, Left_color, [dir_show(choice(2),1)-radius_choice, dir_show(choice(2),2)-radius_choice, dir_show(choice(2),1)+radius_choice, dir_show(choice(2),2)+radius_choice]');    elseif chooseLeft == 0;        Screen('FillOval', curWindow, Right_color, [dir_show(choice(1),1)-radius_choice, dir_show(choice(1),2)-radius_choice, dir_show(choice(1),1)+radius_choice, dir_show(choice(1),2)+radius_choice]');        Screen('FillOval', curWindow, black, [dir_show(choice(2),1)-radius_choice, dir_show(choice(2),2)-radius_choice, dir_show(choice(2),1)+radius_choice, dir_show(choice(2),2)+radius_choice]');    elseif chooseLeft == 1;        Screen('FillOval', curWindow, black, [dir_show(choice(1),1)-radius_choice, dir_show(choice(1),2)-radius_choice, dir_show(choice(1),1)+radius_choice, dir_show(choice(1),2)+radius_choice]');        Screen('FillOval', curWindow, Left_color, [dir_show(choice(2),1)-radius_choice, dir_show(choice(2),2)-radius_choice, dir_show(choice(2),1)+radius_choice, dir_show(choice(2),2)+radius_choice]');    end        if frames <= round(t_moneyOnset*screenInfo.monRefresh)        sizeAngle=0;    else        sizeAngle = sizeAngle + (360*(sv/max_sv))/time_total;    end    Screen('FrameArc',curWindow, white, [xCtr-arc_range yCtr-arc_range xCtr+arc_range yCtr+arc_range], 0,sizeAngle_total,4);    arc_range_K=arc_range+2;    Screen('FrameArc',curWindow, black, [xCtr-arc_range_K yCtr-arc_range_K xCtr+arc_range_K yCtr+arc_range_K], 0,sizeAngle,10);        %   if frames <= round(t_constrain*screenInfo.monRefresh)    %     Screen('FrameArc',curWindow, white, [xCtr-152 yCtr-152 xCtr+152 yCtr+152], 0,sizeAngle_total,4);    %     Screen('FrameArc',curWindow, [0 0 0], [xCtr-153 yCtr-153 xCtr+153 yCtr+153], 0,sizeAngle,10);    %   else    %       if currTime<=t_constrain    %           break    %       else    %           if RT>=t_constrain    %           break    %           else    %               Screen('FrameArc',curWindow, white, [xCtr-152 yCtr-152 xCtr+152 yCtr+152], 0,sizeAngle_total,4);    %               Screen('FrameArc',curWindow, [0 0 0], [xCtr-153 yCtr-153 xCtr+153 yCtr+153], 0,sizeAngle,10);    %           end    %       end    %   end    %     Screen('FrameArc',curWindow, white, [xCtr-152 yCtr-152 xCtr+152 yCtr+152], 0,sizeAngle_total,4);    %     Screen('FrameArc',curWindow, [0 0 0], [xCtr-153 yCtr-153 xCtr+153 yCtr+153], 0,sizeAngle,10);    %    %    if currTime<=t_constrain        if frames <= round(t_constrain*screenInfo.monRefresh)            Screen('FrameArc',curWindow, white, [xCtr-arc_range yCtr-arc_range xCtr+arc_range yCtr+arc_range], 0,sizeAngle_total,4);            Screen('FrameArc',curWindow, black, [xCtr-arc_range_K yCtr-arc_range_K xCtr+arc_range_K yCtr+arc_range_K], 0,sizeAngle,10);        else            break        end    else        if RT>0 && RT<=t_constrain            if frames <= round(t_constrain*screenInfo.monRefresh)                Screen('FrameArc',curWindow, white, [xCtr-arc_range yCtr-arc_range xCtr+arc_range yCtr+arc_range], 0,sizeAngle_total,4);                Screen('FrameArc',curWindow, black, [xCtr-arc_range_K yCtr-arc_range_K xCtr+arc_range_K yCtr+arc_range_K], 0,sizeAngle,10);            else                break            end        elseif RT >t_constrain            break        elseif RT==-1            Screen('FrameArc',curWindow, white, [xCtr-arc_range yCtr-arc_range xCtr+arc_range yCtr+arc_range], 0,sizeAngle_total,4);            Screen('FrameArc',curWindow, black, [xCtr-arc_range_K yCtr-arc_range_K xCtr+arc_range_K yCtr+arc_range_K], 0,sizeAngle,10);        end    end            if mod(indx,round(time_total/(currTime*inputs(blockNo).sampleRate))) == 0        x = x+1;        y = y+1;        count = count + 1;        % Screen('Flip',curWindow);        t_stim_pass = t_stim_pass + (1/(inputs(blockNo).sampleRate));    end    frames = frames + 1;        % check for end of loop    continue_show = continue_show - 1;    indx = indx + 1;    end% present last frame of dotsScreen('Flip', curWindow,0,dontclear);% if the subject does not make a response during stimulus presentation,% then show red fixation and the subject has to respond before the red% fixation disappears.%chooseRif chooseLeft == -1    % fixation for making a response    Screen(screenInfo.curWindow,'DrawLine',red,xCtr,yCtr-width_fix/2,xCtr,yCtr+width_fix/2,2);    Screen(screenInfo.curWindow,'DrawLine',red,xCtr+width_fix/2,yCtr,xCtr-width_fix/2,yCtr,2);            t_fixStart=Screen(screenInfo.curWindow,'Flip');        %     fix_but=0.5; %determine the time force subj to make response        while 1        timePast=GetSecs-t_fixStart;        if timePast>fix_but            break        end        [buttonPress,time,keyCode]=KbCheck;        if buttonPress            if strcmp(KbName(keyCode),rightKey)                chooseLeft=0;                RT=time-start_time;                                break            elseif strcmp(KbName(keyCode),leftKey)                chooseLeft=1;                RT=time-start_time;                                break            elseif strcmp(KbName(keyCode),'ESCAPE')                endExpt=1;                break            end        end            endendif endExpt==1    Screen('CloseAll')end% test=GetSecs-start_timeScreen(screenInfo.curWindow,'Flip');